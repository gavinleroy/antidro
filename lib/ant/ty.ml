[@@@warning "-27"]

open Ppx_hash_lib.Std
open Hash.Builtin
open Sexplib.Std
module Sexp = Sexplib.Sexp
open Util

module type Identifier = sig
  type t [@@deriving sexp_of, show, eq, ord, hash]

  val to_string : t -> string

  val compare : t -> t -> int

  val fresh : ?prefix:string -> unit -> t

  val var : string -> t

  val derivative : t -> t

  val raw : string -> t

  val pp : Format.formatter -> t -> unit
end

module Id : Identifier = struct
  type t = (string[@hash.ignore]) * int [@@deriving eq, ord, hash]

  let pp fmt (s, i) = Format.fprintf fmt "%s_%d" s i

  let to_string id = Format.asprintf "%a" pp id

  let show = to_string

  let sexp_of_t s = Sexp.Atom (to_string s)

  (* Remove all characters that can't appear in a JS symbol *)
  let sanitize s = String.map (function '-' -> '_' | '+' -> 'P' | c -> c) s

  let fresh =
    let counter = ref 0 in
    fun ?(prefix = "gensym") () ->
      incr counter ;
      (sanitize prefix, !counter)

  let var s = fresh ~prefix:s ()

  let derivative (s, _) = fresh ~prefix:s ()

  (* NOTE, zero is reserved for raw symbols. These are generated by the compiler *)
  (* and gauranteed to be unique in the defining context *)
  let raw s = (s, 0)

  let pp fmt s = to_string s |> Format.pp_print_text fmt
end

(* Represents symbols provided by the language *)
module Prim : Identifier = Id

module MetaVar : Identifier = Id

module TyVar : Identifier = Id

module Symbol = struct
  include Id

  let return = var "result"
end

module Group : Identifier = Id

module Slot : sig
  type t [@@deriving sexp_of, show, eq, ord, hash]

  val return : t

  val broadcast : t

  val children : t

  val compare : t -> t -> int

  val to_string : t -> string

  val of_string : string -> t

  val pp : Format.formatter -> t -> unit
end = struct
  type t = string [@@deriving sexp_of, show, eq, ord, hash]

  let of_string s = s

  let to_string s = s

  let broadcast = of_string "broadcast"

  let return = of_string "ret"

  let children = of_string "children"

  let compare = String.compare

  let pp fmt s = Format.pp_print_string fmt s
end

module Place = struct
  type index = LitI of int | DynI of Symbol.t | SplatI
  [@@deriving sexp_of, eq, ord, hash]

  type adjustment = SlotAdj of Slot.t | OffAdj of index
  [@@deriving sexp_of, eq, ord, hash]

  type base = HoleB | VarB of Symbol.t [@@deriving sexp_of, eq, ord, hash]

  (* NOTE, adjustment are stored in reverse order, *)
  (*  the place `posns[0].x` is represented as *)
  (*  ("posns, [Slot "x"; Offset 0]"). *)
  type t = base * adjustment list [@@deriving sexp_of, eq, ord, hash]

  let pp_base fmt = function
    | HoleB ->
        Format.pp_print_string fmt "<>"
    | VarB id ->
        Symbol.pp fmt id

  let pp_adj fmt = function
    | SlotAdj s ->
        Format.fprintf fmt ".%a" Slot.pp s
    | OffAdj (LitI n) ->
        Format.fprintf fmt "[%d]" n
    | OffAdj (DynI id) ->
        Format.fprintf fmt "[%a]" Symbol.pp id
    | OffAdj SplatI ->
        Format.fprintf fmt "[*]"

  let pp fmt (base, adjs) =
    Format.fprintf fmt "%a%a" pp_base base
      (Format.pp_list ~pp_sep:Format.pp_print_nothing pp_adj)
      (List.rev adjs)

  let subst bbs (base, adjs) =
    List.assoc_opt base bbs
    |> Option.map (fun id -> (VarB id, adjs))
    |> Option.value ~default:(base, adjs)

  let is_inner (_, adjs) = List.is_empty adjs |> not

  let hole = (HoleB, [])

  let replace_inner ((b, adjs_inner) : t) ((_, adjs_outer) : t) : t =
    (b, adjs_inner @ adjs_outer)

  let is_hole (base, _) = base = HoleB

  let get_adjustments (_, adjs) = adjs

  let get_id_base : t -> (Symbol.t, 'e) result = function
    | VarB id, _ ->
        Result.ok id
    | _, _ ->
        Result.error "place is not a variable"

  let has_id_base id pl =
    get_id_base pl |> Result.map (Symbol.equal id) |> Result.is_ok

  let plug inner (pl : t) : t =
    if is_hole pl then replace_inner inner pl else pl

  let references id (base, _) =
    match base with VarB id' -> id = id' | _ -> false

  let swap_id ((f, pl') : Symbol.t * t) (pl : t) : t =
    if has_id_base f pl then replace_inner pl' pl else pl

  let base (b : base) : t = (b, [])

  let baseid (id : Symbol.t) : t = base (VarB id)

  let adj ((base, adjs) : t) (adj : adjustment) = (base, adj :: adjs)

  let offset (n : int) (pl : t) : t = adj pl (OffAdj (LitI n))

  let offsetid (n : int) (id : Symbol.t) : t = offset n (baseid id)

  let dynoffset (id : Symbol.t) (pl : t) : t = adj pl (OffAdj (DynI id))

  let slot (sl : Slot.t) (pl : t) : t = adj pl (SlotAdj sl)

  let slotid (sl : Slot.t) (id : Symbol.t) : t = slot sl (baseid id)

  let return = baseid (Symbol.var "result")

  let return_to_hole : t -> t = swap_id (Symbol.return, hole)

  let to_string (base, adjs) =
    let base_str =
      match base with HoleB -> "hole" | VarB id -> Symbol.to_string id
    in
    let index_str = function
      | LitI n ->
          string_of_int n
      | DynI id ->
          Symbol.to_string id
      | SplatI ->
          "splat"
    in
    let adjs_str =
      List.rev_map
        (function
          | SlotAdj sl -> Slot.to_string sl | OffAdj i -> "off_" ^ index_str i
          )
        adjs
    in
    String.concat "_" ("updater" :: base_str :: adjs_str)

  let to_updater_id (pl : t) : Symbol.t = to_string pl |> Symbol.raw

  let to_updater_slot (pl : t) : Slot.t =
    to_string (replace_inner return pl) |> Slot.of_string
end

module type PlaceToPlaces = sig
  type t [@@deriving sexp_of, show, eq, ord]

  val destructure : t -> Place.t * Place.t list

  val on : Place.t -> Place.t list -> t
end

module Dep = struct
  type t = Place.t * Place.t list [@@deriving eq, ord]

  let pp fmt (pl, pls) =
    Format.fprintf fmt "%a^{%a}" Place.pp pl (Format.pp_list Place.pp) pls

  let show = Format.asprintf "%a" pp

  let sexp_of_t t = Sexp.Atom (Format.asprintf "%a" pp t)

  let destructure t = t

  let deps pls = (Place.hole, pls)

  let on (pl : Place.t) (pls : Place.t list) : t = (pl, pls)

  let is_result_dep (pl, _) = Place.get_id_base pl |> Result.is_error

  let is_inner_dep (pl, _) = Place.is_inner pl
end

(* NOTE, all effects are `Write` effects, so no distinction here *)
module Eff = struct
  type t = Place.t * Place.t list [@@deriving eq, ord]

  let pp fmt (pl, pls) =
    Format.fprintf fmt "Write<{%a}, %a>" (Format.pp_list Place.pp) pls Place.pp
      pl

  let sexp_of_t t = Sexp.Atom (Format.asprintf "%a" pp t)

  let show = Format.asprintf "%a" pp

  let destructure t = t

  let on (pl : Place.t) (pls : Place.t list) : t = (pl, pls)
end

module PlaceMap = struct
  module M = Map.Make (Place)
  module S = Set.Make (Place)

  type t = S.t M.t

  module Impl (Elt : PlaceToPlaces) : sig
    type elt = Elt.t

    val union_to : Place.t -> S.t -> t -> t

    val add_to : Place.t -> Place.t list -> t -> t

    val empty : t

    val of_list : elt list -> t

    val to_list : t -> elt list

    val singleton : elt -> t

    val on_opt : Place.t -> t -> Place.t list option

    val on : Place.t -> t -> Place.t list

    val adjust : (Place.t -> Place.t) -> t -> t

    val sexp_of_t : t -> Sexp.t

    val pp : Format.formatter -> t -> unit

    val merge : t -> t -> t

    val ( @ ) : t -> t -> t

    val invert : t -> t

    val assert_empty : t -> (unit, Error.t) result

    val equal : t -> t -> bool
  end = struct
    type elt = Elt.t

    let union_to (k : S.elt) (s : S.t) (m : t) : t =
      M.find_opt k m
      |> Option.value ~default:S.empty
      |> S.union s
      |> fun s -> M.add k s m

    let add_to (k : S.elt) (ls : Place.t list) (m : t) : t =
      union_to k (S.of_list ls) m

    let empty = M.empty

    let of_list (ls : Elt.t list) : t =
      List.fold_left
        (fun m dep ->
          let pl, pls = Elt.destructure dep in
          add_to pl pls m )
        M.empty ls

    let to_list (m : t) : Elt.t list =
      M.to_list m |> List.map (fun (pl, pls) -> Elt.on pl (S.to_list pls))

    let singleton (dep : Elt.t) : t = of_list [dep]

    let on_opt (pl : Place.t) (m : t) : Place.t list option =
      M.find_opt pl m |> Option.map S.elements

    let on (pl : Place.t) (m : t) : Place.t list =
      on_opt pl m |> Option.value ~default:[]

    let sexp_of_t m = Sexp.List (to_list m |> List.map Elt.sexp_of_t)

    let pp fmt m = Format.fprintf fmt "%a" (Format.pp_list Elt.pp) (to_list m)

    let merge m1 m2 = M.fold (fun k v m -> union_to k v m) m2 m1

    let ( @ ) = merge

    let invert (m : t) : t =
      M.fold
        (fun k v m -> List.fold_right (fun v -> add_to v [k]) (S.elements v) m)
        m M.empty

    let adjust (f : Place.t -> Place.t) (m : t) : t =
      M.fold (fun k v -> M.add (f k) (S.map f v)) m M.empty

    let assert_empty (m : t) : (unit, Error.t) result =
      if M.is_empty m then Result.ok ()
      else Result.error "expected empty set, but got: %a" pp m

    let equal (m1 : t) (m2 : t) : bool = M.equal S.equal m1 m2
  end
end

type ty =
  | MetaT of MetaVar.t
  | VarT of TyVar.t
  | GroupT of Group.t
  | SetT of ty list
  | PlaceT of Place.t
  | AppT of tycon * ty list
  | PolyT of TyVar.t list * ty
[@@deriving sexp_of, show]

and tycon =
  | VoidC
  | NumberC
  | StringC
  | BoolC
  (* NOTE, the first argument is the *dependent,* *)
  (* the remaining n-1 arguments are the *dependencies.* *)
  (* (inside of a SetT) *)
  | DepsC
  (* NOTE, The arguments t1, t2, ..., tn *)
  (* to an `ArrowC` represent *)
  (* t_1: dependency set *)
  (* t_2: effect set *)
  (* t_3: return name *)
  (* t_4: return type *)
  (* t_5 - t_n: forall i. 5 <= i <= n, *)
  (*            t_i is the argument name, *)
  (*            t_(i + 1) is the respective type *)
  | ArrowC
  | ArrayC
  | RefC
  | StructC of Slot.t list
  | TyFnC of TyVar.t list * ty
[@@deriving sexp_of, show]

module TySubst : sig
  type t [@@deriving show]

  val empty : t

  val insert_tv : TyVar.t -> ty -> t -> t

  val insert_id : Symbol.t -> ty -> t -> t

  val lookup : ty -> t -> ty option
end = struct
  module TMap = Map.Make (TyVar)
  module SMap = Map.Make (Symbol)

  type t = ty TMap.t * ty SMap.t

  let pp fmt (tvs, ids) =
    let fmt_binding kfmt fmt (k, v) =
      Format.fprintf fmt "%a: %a" kfmt k pp_ty v
    in
    Format.fprintf fmt "{@[<hov>%a@]}@.{@[<hov>%a@]}@."
      (Format.pp_list (fmt_binding TyVar.pp))
      (TMap.bindings tvs)
      (Format.pp_list (fmt_binding Symbol.pp))
      (SMap.bindings ids)

  let show = Format.asprintf "%a" pp

  let empty = (TMap.empty, SMap.empty)

  let insert_tv id ty (tvs, ids) = (TMap.add id ty tvs, ids)

  let insert_id id ty (tvs, ids) = (tvs, SMap.add id ty ids)

  let lookup ty (tvs, ids) =
    match ty with
    | VarT id ->
        TMap.find_opt id tvs
    | PlaceT pl -> (
      match Place.get_id_base pl with
      | Ok id ->
          SMap.find_opt id ids
      | Error _ ->
          None )
    | _ ->
        None
end

module TyCon = struct
  type t = tycon [@@deriving sexp_of, show]
end

module Ty = struct
  module Meta = struct
    module MTable = Hashtbl.Make (MetaVar)

    let sm : ty MTable.t ref = ref (MTable.create 1000)

    let insert = MTable.add !sm

    let lookup = MTable.find_opt !sm

    let find = MTable.find !sm

    let mem = MTable.mem !sm

    let transaction f =
      let saved = MTable.copy !sm in
      let res = f () in
      sm := saved ;
      res
  end

  module SymbMap = Map.Make (Symbol)

  type t = ty [@@deriving sexp_of, show]

  let new_meta () : t = MetaT (MetaVar.fresh ())

  let new_method_group () : t = GroupT (Group.fresh ())

  let unknown = new_meta ()

  let bool = AppT (BoolC, [])

  let number = AppT (NumberC, [])

  let string = AppT (StringC, [])

  let void = AppT (VoidC, [])

  let place (pl : Place.t) : t = PlaceT pl

  let placeid (id : Symbol.t) : t = PlaceT (Place.baseid id)

  let ref (t : t) : t = AppT (RefC, [t])

  let array (t : t) : t = AppT (ArrayC, [t])

  let struct_ (fields : (Slot.t * t) list) : t =
    let fields, tys = List.split fields in
    AppT (StructC fields, tys)

  let func ?(deps : t = new_meta ()) ?(effs : t = new_meta ())
      (formals : (Symbol.t * ty) list) (ret : ty) : ty =
    let names, tys = List.split formals in
    let names = List.map (fun id -> PlaceT (Place.baseid id)) names in
    AppT
      ( ArrowC
      , deps :: effs :: PlaceT Place.return :: ret
        :: List.interleave_exn names tys )

  let arrow ?(tyvars : TyVar.t list = []) ?(deps : t = new_meta ())
      ?(effs : t = new_meta ()) (formals : (Symbol.t * ty) list) (ret : ty) : ty
      =
    PolyT (tyvars, func ~deps ~effs formals ret)

  let dep (t : t) (ts : ty list) : t = AppT (DepsC, [t; SetT ts])

  let as_dep = function
    | AppT (DepsC, [t; SetT ts]) ->
        Ok (t, ts)
    | t ->
        Result.error "type not a dependency %a" pp t

  let as_ref_inner_ty = function AppT (RefC, [t]) -> Some t | _ -> None

  let is_ref (t : t) = as_ref_inner_ty t |> Option.is_some

  let as_group (t : t) : (Group.t, Error.t) result =
    match t with
    | GroupT id ->
        Result.ok id
    | _ ->
        Result.error "expected a group"

  let is_group (t : t) : bool = as_group t |> Result.is_ok

  let as_place : t -> (Place.t, Error.t) result = function
    | PlaceT pl ->
        Result.ok pl
    | _ ->
        Result.error "not a place"

  let as_place_id (t : t) : (Symbol.t, Error.t) result =
    as_place t |> Result.bind' Place.get_id_base

  let struct_fields (t : t) : ((Slot.t * t) list, Error.t) result =
    match t with
    | AppT (StructC fields, tys) ->
        List.zip fields tys
    | _ ->
        Result.error "expected a struct type, but got: %a" pp t

  let lookup_slot (s : Slot.t) (t : t) : (t, Error.t) result =
    let open ResultMonad in
    let* zipped = struct_fields t in
    match List.find_opt (fun (f, _) -> Slot.equal f s) zipped with
    | Some (_, ty) ->
        return ty
    | None ->
        Result.error "slot %a not found in type %a" Slot.pp s pp t

  let subst_of tvars tys : TySubst.t =
    List.fold_right2 TySubst.insert_tv tvars tys TySubst.empty

  let rec subst (s : TySubst.t) (t : t) : t =
    match TySubst.lookup t s with
    | Some t' ->
        t'
    | None -> (
      match t with
      | MetaT a -> (
          Meta.lookup a |> function Some t -> subst s t | None -> t )
      | SetT tys ->
          SetT (List.map (subst s) tys)
      | AppT (TyFnC (tvars, ty), tys) ->
          subst_of tvars tys |> fun s' -> subst s ty |> subst s
      | AppT (tycon, tys) ->
          AppT (tycon, List.map (subst s) tys)
      | PolyT (tvars, ty) ->
          let fresh = List.map (fun _ -> TyVar.fresh ()) tvars in
          let tys = List.map (fun id -> VarT id) fresh in
          let s' = subst_of tvars tys in
          let ty' = subst s' ty in
          PolyT (fresh, subst s ty')
      | t ->
          t )

  let unify_error t u =
    Result.error "unification failed between:@.%a@.and@.%a" pp t pp u

  let rec unify' (t : t) (u : t) : (unit, Error.t) result =
    let open ResultMonad in
    let error () = unify_error t u in
    match (t, u) with
    | VarT a, VarT b when a = b ->
        Result.ok ()
    | PlaceT pl, PlaceT pl' when Place.equal pl pl' ->
        Result.ok ()
    | MetaT a, t -> (
        Meta.lookup a
        |> function
        | Some t' ->
            unify' t' t
        | None -> (
          match t with
          | AppT (TyFnC _, _) ->
              unify' (MetaT a) (expand u)
          | MetaT b when Meta.mem b ->
              unify' (MetaT a) (Meta.find b)
          | MetaT b when a = b ->
              Result.ok ()
          | _ when not (occurs (MetaT a) t) ->
              Meta.insert a t |> Result.ok
          | _ ->
              error () ) )
    | t, MetaT a ->
        unify' (MetaT a) t
    | SetT tys, SetT uys ->
        (* FIXME, we're going to run into problems here because the types aren't *ordered* *)
        List.every2 unify' tys uys
    | AppT (ArrowC, args), AppT (ArrowC, args')
      when List.length args = List.length args' ->
        let argnames = function
          | _effs :: _deps :: return :: _returnty :: args ->
              let* names, _ = List.uninterleave args in
              List.all as_place_id (return :: names)
          | args ->
              Result.error "ArrowC incorrect number of arguments %a"
                (Format.pp_list pp) args
        in
        let* argnames' = argnames args' in
        let* argnames = argnames args in
        let subst_arg_names =
          List.fold_right2
            (fun fid tid -> TySubst.insert_id fid (PlaceT (Place.baseid tid)))
            argnames' argnames TySubst.empty
          |> subst
        in
        let args' = List.map subst_arg_names args' in
        List.every2 unify' args args'
    | AppT (tycon1, args), AppT (tycon2, args') when tycon1 = tycon2 ->
        List.every2 unify' args args'
    | AppT (TyFnC (tyvars, u), tys), t ->
        subst (subst_of tyvars tys) u |> fun u' -> unify' u' t
    | t, AppT (TyFnC (tyvars, u), tys) ->
        subst (subst_of tyvars tys) u |> unify' t
    | PolyT (tyvars, u), PolyT (tyvars', u')
      when List.length tyvars = List.length tyvars' ->
        let s' = subst_of tyvars' (List.map (fun id -> VarT id) tyvars) in
        subst s' u' |> unify' u
    | _, _ ->
        error ()

  and unify (t : t) (u : t) : (unit, Error.t) result =
    try unify' t u with Invalid_argument _ -> unify_error t u

  and expand (t : t) : t =
    match t with
    | AppT (TyFnC (tvars, u), tys) ->
        subst (subst_of tvars tys) u |> expand
    | MetaT a when Meta.mem a ->
        expand (Meta.find a)
    | t ->
        t

  and occurs (u : t) (t : t) : bool =
    match t with
    | MetaT a ->
        Meta.lookup a
        |> Option.map (fun t' -> occurs u t')
        |> Option.value ~default:false
    | SetT tys | AppT (_, tys) ->
        List.exists (occurs u) tys
    | PolyT (_, k) ->
        occurs u k
    | q when q = u ->
        true
    | _ ->
        false

  let rec meta_vars_in (t : t) : MetaVar.t list =
    match t with
    | MetaT m ->
        [m]
    | SetT ts | AppT (_, ts) ->
        List.concat_map meta_vars_in ts
    | PolyT (_, t) ->
        meta_vars_in t
    | _ ->
        []

  let generalize (s : t SymbMap.t) (t : t) : t =
    let t_0 = subst TySubst.empty t in
    let metas =
      meta_vars_in t_0
      |> List.filter (fun v ->
             not (SymbMap.exists (fun _ t' -> occurs (MetaT v) t') s) )
    in
    let tyvars = List.map (fun _ -> TyVar.fresh ()) metas in
    List.iter2 (fun m tv -> Meta.insert m (VarT tv)) metas tyvars ;
    let t = PolyT (tyvars, t_0) in
    Logs.debug (fun m -> m "generalized %a to: %a" pp t_0 pp t) ;
    t

  let instantiate (t : t) : t =
    match t with
    | PolyT (tvars, t) ->
        let mvars = List.map (fun _ -> new_meta ()) tvars in
        subst (subst_of tvars mvars) t
    | _ ->
        t
end

module Dependencies = struct
  include PlaceMap.Impl (Dep)

  type t = PlaceMap.t

  let adjust_lhs f m =
    PlaceMap.M.fold (fun k v m -> PlaceMap.M.add (f k) v m) m PlaceMap.M.empty

  (* Replace dependencies in `t` that reference a place built on `id`, using the *)
  (* dependencies in `idbound`. *)
  let purge (id : Symbol.t) (idbound : t) (t : t) : t =
    let purge_set (s : PlaceMap.S.t) =
      PlaceMap.S.fold
        (fun el s ->
          if Place.references id el then
            PlaceMap.M.find_opt el idbound
            |> Option.value ~default:PlaceMap.S.empty
            |> PlaceMap.S.union s
          else PlaceMap.S.add el s )
        s PlaceMap.S.empty
    in
    PlaceMap.M.map purge_set t

  let of_ty : Ty.t -> (t, Error.t) result = function
    | SetT tys ->
        (* FIXME: not handled, type variables *)
        (* E.g., `forall<R> R`, `forall<R> { result^R }`, ... *)
        let open ResultMonad in
        let* as_deps = List.all Ty.as_dep tys in
        let+ deps =
          List.all
            (fun (t, ts) ->
              let* pl = Ty.as_place t in
              let+ pls = List.all Ty.as_place ts in
              Dep.on pl pls )
            as_deps
        in
        of_list deps
    | t ->
        Result.error "TODO: convert ty to dependencies %a" Ty.pp t

  let to_ty (ls : t) =
    to_list ls |> List.map Dep.destructure
    |> List.map (fun (pl, pls) -> Ty.dep (Ty.place pl) (List.map Ty.place pls))
    |> fun tys -> SetT tys
end

module Effects = struct
  include PlaceMap.Impl (Eff)

  type t = PlaceMap.t

  let extend (d : Dependencies.t) (m : t) =
    List.fold_left
      (fun m dep ->
        let pl, pls = Dep.destructure dep in
        add_to pl pls m )
      m (Dependencies.to_list d)

  let ( ++ ) m d = extend d m

  let remove (id : Symbol.t) (m : t) : t =
    PlaceMap.M.filter (fun pl _ -> not (Place.references id pl)) m

  let of_ty (ty : Ty.t) : (t, Error.t) result =
    (* FIXME TODO *)
    ignore ty ;
    Result.error "TODO: effs_of_ty"

  let to_ty (ls : t) =
    (* FIXME TODO *)
    ignore ls ; SetT []
end

module Signature = struct
  open Util.ResultMonad

  type t =
    { tyvars: TyVar.t list
    ; ids: Symbol.t list
    ; args: ty list
    ; deps: ty
    ; effs: ty
    ; return: ty }
  [@@deriving sexp_of]

  let pp fmt {tyvars; ids; args; deps; effs; return} =
    let pp_args =
      Format.pp_list (fun fmt (id, ty) ->
          Format.fprintf fmt "%a: %a" Symbol.pp id Ty.pp ty )
    in
    Format.fprintf fmt "(%a) -> %a | {TODO}" pp_args (List.combine ids args)
      Ty.pp return

  let show = Format.asprintf "%a" pp

  let formals s = List.combine s.ids s.args

  let from_instantiated : ty -> (t, 'e) result = function
    | AppT (ArrowC, deps :: effs :: _return :: return :: args) ->
        let* names, args = List.uninterleave args in
        let+ ids =
          List.all
            (fun ty -> Ty.as_place ty |> Result.bind' Place.get_id_base)
            names
        in
        {tyvars= []; ids; args; deps; effs; return}
    | t ->
        Result.error "expected an instantiated function, but got: %a" Ty.pp t

  let from_ty : ty -> (t, 'e) result = function
    | PolyT (tyvars, app) ->
        let+ inst = from_instantiated app in
        {inst with tyvars}
    | t ->
        Result.error "expected a polymorphic function, but got: %a" Ty.pp t

  let to_ty ({tyvars; ids; args; deps; effs; return} : t) : ty =
    let args = List.interleave_exn (List.map Ty.placeid ids) args in
    PolyT
      ( tyvars
      , AppT (ArrowC, deps :: effs :: PlaceT Place.return :: return :: args) )

  let is t = from_ty t |> Result.is_ok

  let uninstantiated_deps self : Dependencies.t option = failwith "TODO"

  let return (ty : ty) : (ty, 'e) result =
    let+ {return; _} = from_instantiated ty in
    return

  let args (ty : ty) : ((Symbol.t * ty) list, 'e) result =
    let* {ids; args; _} = from_instantiated ty in
    List.zip ids args

  let dependencies (args : Place.t list) (ty : ty) : (Dependencies.t, 'e) result
      =
    let* {ids; deps; _} = from_instantiated ty in
    let* deps = Dependencies.of_ty deps in
    let+ map = List.zip ids args in
    let deps_after =
      List.fold_right
        (fun swap -> Dependencies.adjust (Place.swap_id swap))
        map deps
      |> Dependencies.adjust_lhs Place.return_to_hole
    in
    Logs.debug (fun m ->
        m "instantiating-dependencies@.map: %a@.before:@.%a@.after:@.%a"
          (Format.pp_list (fun fmt (id, pl) ->
               Format.fprintf fmt "%a: %a" Symbol.pp id Place.pp pl ) )
          map Dependencies.pp deps Dependencies.pp deps_after ) ;
    deps_after

  let effects (args : Place.t list) (ty : ty) : (Effects.t, 'e) result =
    let* {ids; effs; _} = from_instantiated ty in
    let* effs = Effects.of_ty effs in
    Logs.debug (fun m ->
        m "instantiating-effects with (effs: %a) (args: %a)" Effects.pp effs
          (Format.pp_list Place.pp) args ) ;
    let+ map = List.zip ids args in
    let instantiate_effect eff =
      let pl, pls = Eff.destructure eff in
      (* For each affecting place, we swap it with its dependencies  *)
      let pls =
        List.fold_right
          (fun swap pls -> List.map (Place.swap_id swap) pls)
          map pls
      in
      let pl = List.fold_right Place.swap_id map pl in
      Eff.on pl pls
    in
    List.map instantiate_effect (Effects.to_list effs) |> Effects.of_list

  (* Resolve the specific method overload from the MethodGroup in `fty` *)
  let resolve_application (overloads : (Symbol.t * Ty.t) list)
      (argstys : Ty.t list) : (Symbol.t * Ty.t, Error.t) result =
    let open Util.ResultMonad in
    Logs.debug (fun m ->
        m "Resolving application of args@.@[%a@]@.with overloads@.@[%a@]\n"
          (Format.pp_list Ty.pp) argstys
          ( Format.pp_list ~pp_sep:Format.pp_print_newline
          @@ fun fmt (id, fty) ->
          Format.fprintf fmt "%a: %a" Symbol.pp id Ty.pp fty )
          overloads ) ;
    let unify_overload (_, fty) =
      let fty = Ty.instantiate fty in
      let* ids = args fty |> Result.map (List.map fst) in
      let mret = Ty.new_meta () in
      let* args = List.zip ids argstys in
      let msig = Ty.func args mret in
      Logs.debug (fun m ->
          m "checking overload with signature@.@[%a@]@.@[%a@]" Ty.pp fty Ty.pp
            msig ) ;
      Ty.unify fty msig
    in
    (* Run the checking in a transaction so that we don't clutter the meta variables *)
    let is_applicable_overload overload =
      Ty.Meta.transaction (fun () -> unify_overload overload |> Result.is_ok)
    in
    match List.filter is_applicable_overload overloads with
    | [] ->
        Result.error "no matching overload"
    | [(id, fty)] ->
        return (id, fty |> Ty.instantiate)
    | _ ->
        Result.error "Ambiguous application, multiple matching overloads"
end
