[@@@warning "-27"]

open Ppx_hash_lib.Std
open Hash.Builtin
open Sexplib.Std
module Sexp = Sexplib.Sexp
open Util

type error = [`Msg of string] [@@deriving sexp, show]

module type Identifier = sig
  type t [@@deriving sexp, show, eq, ord, hash]

  val to_string : t -> string

  val compare : t -> t -> int

  val fresh : ?prefix:string -> unit -> t

  val var : string -> t

  val derivative : t -> t

  val raw : string -> t

  val pp : Format.formatter -> t -> unit
end

module Id : Identifier = struct
  type t = (string[@hash.ignore]) * int [@@deriving sexp, show, eq, ord, hash]

  let to_string (s, i) = s ^ "_" ^ string_of_int i

  (* Remove all characters that can't appear in a JS symbol *)
  let sanitize s = String.map (function '-' -> '_' | '+' -> 'P' | c -> c) s

  let fresh =
    let counter = ref 0 in
    fun ?(prefix = "gensym") () ->
      incr counter ;
      (sanitize prefix, !counter)

  let var s = fresh ~prefix:s ()

  let derivative (s, _) = fresh ~prefix:s ()

  (* NOTE, zero is reserved for raw symbols. These are generated by the compiler *)
  (* and gauranteed to be unique in the defining context *)
  let raw s = (s, 0)

  let pp fmt s = to_string s |> Format.pp_print_text fmt
end

(* Represents symbols provided by the language *)
module Prim : Identifier = Id

module MetaVar : Identifier = Id

module TyVar : Identifier = Id

module Symbol : Identifier = Id

module Group : Identifier = Id

module SymbolMap = Map.Make (Symbol)

module Slot : sig
  type t [@@deriving sexp, show, eq, ord]

  val box_value : t

  val return : t

  val children : t

  val compare : t -> t -> int

  val to_string : t -> string

  val of_string : string -> t

  val pp : Format.formatter -> t -> unit
end = struct
  type t = string [@@deriving sexp, show, eq, ord]

  let of_string s = s

  let to_string s = s

  let box_value = of_string "value"

  let return = of_string "retval"

  let children = of_string "children"

  let compare = String.compare

  let pp fmt s = Format.pp_print_string fmt s
end

module Place = struct
  type adjustment =
    | SplatAdj
    | DerefAdj
    | SlotAdj of Slot.t
    | OffAdj of int
    | DynOffAdj of Symbol.t
  [@@deriving sexp, show, eq, ord]

  type base = ResultB | VarB of Symbol.t [@@deriving sexp, show, eq, ord]

  (* NOTE, adjustment are stored in reverse order, *)
  (*  the place `posns[0].x` is represented as *)
  (*  ("posns, [Slot "x"; Offset 0]"). *)
  type t = base * adjustment list [@@deriving sexp, show, eq, ord]

  let subst bbs (base, adjs) =
    List.assoc_opt base bbs
    |> Option.map (fun id -> (VarB id, adjs))
    |> Option.value ~default:(base, adjs)

  let is_inner (_, adjs) = List.is_empty adjs |> not

  let result = (ResultB, [])

  let replace_fres (base, adjs) id =
    match base with ResultB -> (VarB id, adjs) | _ -> (base, adjs)

  let get_id_base = function ResultB, _ -> None | VarB id, _ -> Some id

  let base (b : base) : t = (b, [])

  let baseid (id : Symbol.t) : t = base (VarB id)

  let adj ((base, adjs) : t) (adj : adjustment) = (base, adj :: adjs)

  let deref pl = adj pl DerefAdj

  let derefid id = deref (baseid id)

  let offset (n : int) (pl : t) : t = adj pl (OffAdj n)

  let offsetid (n : int) (id : Symbol.t) : t = offset n (baseid id)

  let dynoffset (id : Symbol.t) (pl : t) : t = adj pl (DynOffAdj id)

  let slot (sl : Slot.t) (pl : t) : t = adj pl (SlotAdj sl)

  let slotid (sl : Slot.t) (id : Symbol.t) : t = slot sl (baseid id)

  let to_string (base, adjs) =
    let base_str =
      match base with ResultB -> "result" | VarB id -> Symbol.to_string id
    in
    let adjs_str =
      List.map
        (function
          | SplatAdj ->
              "splat"
          | DerefAdj ->
              "deref"
          | SlotAdj sl ->
              Slot.to_string sl
          | OffAdj n ->
              String.concat "" ["off_"; string_of_int n]
          | DynOffAdj id ->
              String.concat "" ["dynoff_"; Symbol.to_string id] )
        adjs
    in
    String.concat "_" ("updater" :: base_str :: adjs_str)

  let to_updater_id (pl : t) : Symbol.t = to_string pl |> Symbol.raw

  let to_updater_slot (pl : t) : Slot.t = to_string pl |> Slot.of_string
end

module Dep = struct
  type t = Place.t * Place.t list [@@deriving sexp, show, eq, ord]

  let on (pl : Place.t) (pls : Place.t list) : t = (pl, pls)

  let is_result_dep (pl, _) = Place.get_id_base pl |> Option.is_none

  let is_inner_dep (pl, _) = Place.is_inner pl

  let updater_id (pl, _) = Place.to_updater_id pl
end

(* NOTE, all effects are `Write` effects, so no distinction here *)
module Eff = struct
  type t = Place.t list * Place.t [@@deriving sexp, show, eq, ord]
end

module Dependencies = struct
  type t = Dep.t list [@@deriving sexp, show]

  let of_list ls = ls
end

module Effects = struct
  type t = Eff.t list [@@deriving sexp, show]
end

type ty =
  | MetaT of MetaVar.t
  | VarT of TyVar.t
  | DepsT of Dependencies.t
  | EffsT of Effects.t
  | GroupT of Group.t
  | AppT of tycon * ty list
  | PolyT of TyVar.t list * ty
[@@deriving sexp, show]

and tycon =
  | VoidC
  | NumberC
  | StringC
  | BoolC
  (* NOTE: The arguments t1, t2, ..., tn *)
  (* to an ArrowC asr *)
  (* t1: dependency set *)
  (* t2: effect set *)
  (* t3: return value *)
  (* t4-tn: arguments *)
  | ArrowC of Symbol.t list
  | ArrayC
  | RefC
  | StructC of Slot.t list
  | TyFnC of TyVar.t list * ty
[@@deriving sexp, show]

(* and fnsig = *)
(*   { args: (Symbol.t * ty) list *)
(*   ; return: ty *)
(*   ; dependencies: Dependencies.t *)
(*   ; effects: Effects.t } *)
(* [@@deriving sexp, show] *)

module SymbMap = Map.Make (Symbol)
module TyMap = Map.Make (TyVar)

type ssubst = ty SymbMap.t

type tysubst = ty TyMap.t

module Signature = struct
  open Util.ResultMonad

  type t =
    { tyvars: TyVar.t list
    ; ids: Symbol.t list
    ; args: ty list
    ; deps: ty
    ; effs: ty
    ; return: ty }
  [@@deriving sexp, show]

  let from_ty : ty -> (t, 'e) result = function
    | PolyT (tyvars, AppT (ArrowC ids, deps :: effs :: return :: args)) ->
        Result.ok {tyvars; ids; args; deps; effs; return}
    | t ->
        Result.error
          (`Msg
            ( "expected a polymorphic function, but got: "
            ^ Sexp.to_string_hum (sexp_of_ty t) ) )

  let from_instantiated : ty -> (t, 'e) result = function
    | AppT (ArrowC ids, deps :: effs :: return :: args) ->
        Result.ok {tyvars= []; ids; args; deps; effs; return}
    | t ->
        Result.error
          (`Msg
            ( "expected an instantiated function, but got: "
            ^ Sexp.to_string_hum (sexp_of_ty t) ) )

  let to_ty ({tyvars; ids; args; deps; effs; return} : t) : ty =
    PolyT (tyvars, AppT (ArrowC ids, deps :: effs :: return :: args))

  let is t = from_ty t |> Result.is_ok

  let return (ty : ty) : (ty, 'e) result =
    let+ {return; _} = from_instantiated ty in
    return

  let args (ty : ty) : ((Symbol.t * ty) list, 'e) result =
    let+ {ids; args; _} = from_instantiated ty in
    List.combine ids args
end

module TyCon = struct
  type t = tycon [@@deriving sexp, show]
end

module Ty = struct
  module TMap = Map.Make (TyVar)

  type t = ty [@@deriving sexp, show]

  let to_string s = Sexp.to_string_hum (sexp_of_t s)

  let new_meta () : t = MetaT (MetaVar.fresh ())

  let new_method_group () : t = GroupT (Group.fresh ())

  module Meta = struct
    module MTable = Hashtbl.Make (MetaVar)

    let sm : ty MTable.t ref = ref (MTable.create 1000)

    let insert v = MTable.add !sm v

    let lookup v = MTable.find_opt !sm v

    let find v = MTable.find !sm v

    let mem v = MTable.mem !sm v

    let transaction f =
      let saved = MTable.copy !sm in
      let res = f () in
      sm := saved ;
      res
  end

  let bool = AppT (BoolC, [])

  let number = AppT (NumberC, [])

  let string = AppT (StringC, [])

  let void = AppT (VoidC, [])

  let ref (t : t) : t = AppT (RefC, [t])

  let array (t : t) : t = AppT (ArrayC, [t])

  let struct_ (fields : (Slot.t * t) list) : t =
    let fields, tys = List.split fields in
    AppT (StructC fields, tys)

  let func ?(deps : t = new_meta ()) ?(effs : t = new_meta ())
      (formals : (Symbol.t * ty) list) (ret : ty) : ty =
    let names, tys = List.split formals in
    let tys = deps :: effs :: ret :: tys in
    AppT (ArrowC names, tys)

  let arrow ?(tyvars : TyVar.t list = []) ?(deps : t = new_meta ())
      ?(effs : t = new_meta ()) (formals : (Symbol.t * ty) list) (ret : ty) : ty
      =
    PolyT (tyvars, func ~deps ~effs formals ret)

  let dependencies (ls : Dependencies.t) = DepsT ls

  let effects (ls : Effects.t) = EffsT ls

  let is_ref = function AppT (RefC, _) -> true | _ -> false

  let as_group (t : t) : (Group.t, error) result =
    match t with
    | GroupT id ->
        Result.ok id
    | _ ->
        Result.error (`Msg "expected a group")

  let lookup_slot (s : Slot.t) (t : t) : (t, error) result =
    let open ResultMonad in
    match t with
    | AppT (StructC fields, tys) -> (
        let* zipped = List.zip fields tys in
        match List.find_opt (fun (f, _) -> Slot.equal f s) zipped with
        | Some (_, ty) ->
            return ty
        | None ->
            error
              (`Msg
                (Format.asprintf "slot %a not found in type %a" Slot.pp s pp t)
                ) )
    | _ ->
        Result.error
          (`Msg (Format.asprintf "expected a struct type, but got: %a" pp t))

  let subst_of tvars tys = List.combine tvars tys |> TMap.of_list

  let rec subst (s : tysubst) (t : t) =
    match t with
    | VarT id ->
        TMap.find_opt id s |> Option.value ~default:t
    | MetaT a -> (
        Meta.lookup a |> function Some t -> subst s t | None -> t )
    | AppT (TyFnC (tvars, ty), tys) ->
        subst_of tvars tys |> fun s' -> subst s ty |> subst s
    | AppT (tycon, tys) ->
        AppT (tycon, List.map (subst s) tys)
    | PolyT (tvars, ty) ->
        let fresh = List.map (fun _ -> TyVar.fresh ()) tvars in
        let tys = List.map (fun id -> VarT id) fresh in
        let s' = subst_of tvars tys in
        let ty' = subst s' ty in
        PolyT (fresh, subst s ty')
    | t ->
        t

  let rec unify (t : t) (u : t) : (unit, error) result =
    let error () =
      Result.error
        (`Msg ("unification failed: " ^ to_string t ^ " " ^ to_string u))
    in
    match (t, u) with
    | VarT a, VarT b when a = b ->
        Result.ok ()
    | MetaT a, t -> (
        Meta.lookup a
        |> function
        | Some t' ->
            unify t' t
        | None -> (
          match t with
          | AppT (TyFnC _, _) ->
              unify (MetaT a) (expand u)
          | MetaT b when Meta.mem b ->
              unify (MetaT a) (Meta.find b)
          | MetaT b when a = b ->
              Result.ok ()
          | _ when not (occurs (MetaT a) t) ->
              Meta.insert a t |> Result.ok
          | _ ->
              error () ) )
    | t, MetaT a ->
        unify (MetaT a) t
    | AppT (tycon1, tys1), AppT (tycon2, tys2) when tycon1 = tycon2 ->
        List.fold_left2
          (fun acc ty1 ty2 -> Result.bind acc (fun () -> unify ty1 ty2))
          (Result.ok ()) tys1 tys2
    | AppT (TyFnC (tyvars, u), tys), t ->
        subst (subst_of tyvars tys) u |> fun u' -> unify u' t
    | t, AppT (TyFnC (tyvars, u), tys) ->
        subst (subst_of tyvars tys) u |> unify t
    | PolyT (tyvars, u), PolyT (tyvars', u') ->
        let s' = subst_of tyvars' (List.map (fun id -> VarT id) tyvars) in
        subst s' u' |> unify u
    | DepsT d1, DepsT d2
      when List.equal_membership ~compare:Dep.compare ~equal:Dep.equal d1 d2 ->
        Result.ok ()
    | EffsT e1, EffsT e2
      when List.equal_membership ~compare:Eff.compare ~equal:Eff.equal e1 e2 ->
        Result.ok ()
    | _ ->
        error ()

  and expand (t : t) : t =
    match t with
    | AppT (TyFnC (tvars, u), tys) ->
        subst (subst_of tvars tys) u |> expand
    | MetaT a when Meta.mem a ->
        expand (Meta.find a)
    | t ->
        t

  and occurs (u : t) (t : t) : bool =
    match t with
    | q when q = u ->
        true
    | MetaT a ->
        Meta.lookup a
        |> Option.map (fun t' -> occurs u t')
        |> Option.value ~default:false
    | AppT (_, tys) ->
        List.exists (occurs u) tys
    | PolyT (_, k) ->
        occurs u k
    | _ ->
        false

  let rec meta_vars_in (t : t) : MetaVar.t list =
    match t with
    | MetaT m ->
        [m]
    | AppT (_, ts) ->
        List.concat_map meta_vars_in ts
    | PolyT (_, t) ->
        meta_vars_in t
    | _ ->
        []

  let generalize (s : ssubst) (t : t) : t =
    let metas =
      meta_vars_in t
      |> List.filter (fun v ->
             not (SymbMap.exists (fun _ t' -> occurs (MetaT v) t') s) )
    in
    let tyvars = List.map (fun _ -> TyVar.fresh ()) metas in
    List.iter2 (fun m tv -> Meta.insert m (VarT tv)) metas tyvars ;
    PolyT (tyvars, t)

  let instantiate (t : t) : t =
    match t with
    | PolyT (tvars, t) ->
        let mvars = List.map (fun _ -> new_meta ()) tvars in
        subst (subst_of tvars mvars) t
    | _ ->
        t

  (* Resolve the specific method overload from the MethodGroup in `fty` *)
  let resolve_application (overloads : (Symbol.t * t) list) (args : t list) :
      (Symbol.t * t, error) result =
    let open Util.ResultMonad in
    Logs.debug (fun m ->
        m "Resolving application of args@\n@[%a@]@\nwith overloads@\n@[%a@]\n"
          (Format.pp_print_list pp) args
          ( Format.pp_print_list ~pp_sep:Format.pp_print_newline
          @@ fun fmt (id, fty) ->
          Format.fprintf fmt "%a: %a" Symbol.pp id pp fty )
          overloads ) ;
    let unify_overload (_, fty) =
      let fty = instantiate fty in
      let* ids = Signature.args fty |> Result.map (List.map fst) in
      let mret = new_meta () in
      let* args = List.zip ids args in
      let msig = func args mret in
      Logs.debug (fun m ->
          m "checking overload with signature@\n@[%a@]@\n@[%a@]" pp fty pp msig ) ;
      unify fty msig
    in
    (* Run the checking in a transaction so that we don't clutter the meta variables *)
    let is_applicable_overload overload =
      Meta.transaction (fun () -> unify_overload overload |> Result.is_ok)
    in
    match List.filter is_applicable_overload overloads with
    | [] ->
        error (`Msg "no matching overload")
    | [(id, fty)] ->
        return (id, fty |> instantiate)
    | _ ->
        error (`Msg "Ambiguous application, multiple matching overloads")

  let is_method_group (t : t) : bool = as_group t |> Result.is_ok
end

module Binder = struct
  type 'a t = TyVar.t list * 'a [@@deriving sexp, show]
end
